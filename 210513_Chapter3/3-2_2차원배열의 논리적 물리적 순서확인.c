/*
2차원 배열 구조를 논리적으로 표현할 때는 행과 열의 구조로 나타내지만,
실제로 메모리에 저장될때는 1차원 구조로 저장된다.

2차원인 논리적 순서가 1차원인 물리적 순서로 변환되는 방법에는 행 우선 순서, 열 우선 순서 방법이 있다.

행 우선 순서 방법은 
행을 기준으로 같은 행 안에 있는 열을 먼저 저장하는 방법이다.


열 우선 순서 방법은
열을 기준으로 하여 같은 열 안에 있는 행을 먼저 저장하는 방법이다.


행, 열 우선 순서 방법에따라 물리적 순서가 달라지므로 배열의 원소 위치를 계산하는 방법도 달라져야한다.
보통 C컴파일러는 행 우선 순서 방법을 사용한다.
*/


// 2차원 배열의 논리적, 물리적 순서 확인하기
#include <stdio.h>

int main() 
{
	int i, n = 0, * ptr;
	int sale[2][4] = { {63,84,140,130},{157, 209, 251, 312} }; // 2차원 배열 초기화


	int(* pptr)[4];     // 2차원배열에 호응할 배열 포인터 선언(개수는 열에 맞춰서 4개)
	pptr = &sale; // pptr이 가리킬 시작주소


	ptr = &sale[0][0];  // 2차원 배열을 일반 포인터에 대입(2차원 배열 형태로 쓸수없음)


	// 데이터 출력용으로쓰는 일반포인터와 for문(이렇게 포인터를 사용하면안됨)
	for (i = 0; i < 8; i++)  // 2차원 배열인데 for문 한개로만썼음
	{
		printf("\n address : %u sale %d = %d", ptr, i, *ptr);  // i의 주소값, i값, ptr 값 출력

		// 물리적인 순서를 주소값을 ++하면서 출력을 해주고있음.
		// 대신 2차원 배열의 개념을 사용할 수 없음.(ptr[1][1] 로 표현하면 에러뜸)

		ptr++;   // 4바이트씩 증가
	}

	// printf("\n%d", ptr[1][1]);  // 빨간줄뜸(2차원 배열인데 그냥 포인터로 저장했기때문에 2차원배열을 사용할수없음)
	
	printf("\n%d", pptr[1][1]);
	printf("\n%u", pptr + 1);  // 16바이트 증가됨.(+1은 2차원배열을가리키는 배열 포인터이므로 다음 행을 가리키는 주소가 출력됨)
	printf("\n%u", pptr + 2);
	printf("\n");
	printf("\n%u", (*pptr + 1));
	printf("\n%u", (*pptr + 2));

	getchar();
}


/*
2차원 배열인데 일반 포인터에 저장했다. (원래는 포인터 배열에 저장했었음)

포인터는 다른 자료형의 주소는 읽어올수있지만 데이터값을 불러오면 데이터가 이상하다.

배열포인터, 포인터배열에대해 정리해야할듯

포인터 배열은 포인터가 여러개 모여서 배열로 있는것이고
배열 포인터는 배열 타입만 가리키는 하나의 포인터 입니다.
*/

/*


*/